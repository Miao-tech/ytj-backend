<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å®æ—¶æŠ˜çº¿å›¾ç¤ºä¾‹ (WebSocket)</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: Arial, sans-serif;
            background-color: #f0f2f5;
        }
        #kline-chart {
            width: 100%;
            height: 600px;
            background-color: #fff;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            margin-top: 20px;
        }
        .status-panel {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .status-card {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 10px;
            padding: 15px;
            text-align: center;
        }
        
        .status-value {
            font-size: 1.8em;
            font-weight: bold;
            margin: 5px 0;
        }
        
        .status-label {
            font-size: 0.9em;
            opacity: 0.8;
        }
    </style>
    <!-- ä»…å¼•å…¥ ECharts æ ¸å¿ƒåº“ï¼Œé€šå¸¸è¶³å¤Ÿç”¨äºæŠ˜çº¿å›¾ -->
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
</head>

<body>
    <div class="status-panel">
        <div class="status-card">
            <div class="status-value" id="currentValue">0.00</div>
            <div class="status-label">å½“å‰å€¼</div>
        </div>
        <div class="status-card">
            <div class="status-value" id="maxValue">0.00</div>
            <div class="status-label">æœ€å¤§å€¼</div>
        </div>
        <div class="status-card">
            <div class="status-value" id="minValue">0.00</div>
            <div class="status-label">æœ€å°å€¼</div>
        </div>
        <div class="status-card">
            <div class="status-value" id="avgValue">0.00</div>
            <div class="status-label">å¹³å‡å€¼</div>
        </div>
    </div>
    <div id="kline-chart"></div>
    <div class="control-group">
        <label>è¿è¡Œæ§åˆ¶:</label>
        <button onclick="toggleRunning()" id="runningBtn" class="running-btn">
            <span id="runningIcon">â–¶ï¸</span>
            <span id="runningText">è¿è¡Œ</span>
        </button>
    </div>
    <script>
        // å…¨å±€å˜é‡
        let myChart;
        let websocket;
        let isConnected = false;
        let isRunning = false; // æ·»åŠ è¿è¡ŒçŠ¶æ€æ§åˆ¶ï¼ˆç¤ºæ³¢å™¨ï¼‰
        let dataPoints = [];
        let maxDataPoints = 120; // é»˜è®¤60ç§’ï¼Œæ¯500msä¸€ä¸ªç‚¹
        let currentStats = { current: 0, max: 0, min: 0, avg: 0 };
        let displayRange = { min: 200, max: 300 };

        // ç­‰å¾… DOM åŠ è½½å®Œæ¯•å†æ‰§è¡Œè„šæœ¬
        document.addEventListener('DOMContentLoaded', () => {
            const chartDom = document.getElementById('kline-chart');
            if (!chartDom) {
                console.error("ECharts å®¹å™¨æœªæ‰¾åˆ°ï¼è¯·ç¡®ä¿ DOM ä¸­å­˜åœ¨ id ä¸º 'kline-chart' çš„å…ƒç´ ã€‚");
                return;
            }
            const myChart = echarts.init(chartDom);

            // å­˜å‚¨å›¾è¡¨æ•°æ®ï¼Œåˆå§‹ä¸ºç©ºæˆ–å°‘é‡æ•°æ®
            let chartDates = [];
            let chartValues = [];
            const MAX_DATA_POINTS = 50; // å›¾è¡¨æ˜¾ç¤ºçš„æœ€å¤§æ•°æ®ç‚¹æ•°é‡ï¼Œè¶…è¿‡åˆ™ç§»é™¤æœ€æ—§çš„

            // ECharts é…ç½®é¡¹
            const option = {
                backgroundColor: '#1a1a1a', // ç¤ºæ³¢å™¨æ·±è‰²èƒŒæ™¯
                title: {
                    text: 'ç¤ºæ³¢å™¨æ•°æ®æ³¢å½¢',
                    left: 'center',
                    textStyle: {
                        color: '#f7df1e',
                        fontSize: 18,
                        fontWeight: 'bold'
                    }
                },
                tooltip: {
                    trigger: 'axis',
                    backgroundColor: 'rgba(0,0,0,0.8)',
                    borderColor: '#f7df1e',
                    textStyle: {
                        color: '#fff'
                    },
                    formatter: function(params) {
                        const data = params[0];
                        return `æ—¶é—´: ${data.name}<br/>æ•°å€¼: ${data.value.toFixed(2)}`;
                    }
                },
                grid: {
                    left: '5%',
                    right: '5%',
                    bottom: '5%',
                    top: '12%',
                    containLabel: true,
                    backgroundColor: '#000',
                    borderColor: '#333'
                },
                toolbox: {
                    feature: {
                        saveAsImage: {
                            title: 'ä¿å­˜å›¾ç‰‡',
                            iconStyle: {
                                borderColor: '#f7df1e'
                            }
                        }
                    },
                    iconStyle: {
                        borderColor: '#f7df1e'
                    }
                },
                xAxis: {
                    type: 'category',
                    boundaryGap: false,
                    data: [],
                    axisLine: {
                        lineStyle: {
                            color: '#333'
                        }
                    },
                    axisTick: {
                        lineStyle: {
                            color: '#333'
                        }
                    },
                    axisLabel: {
                        color: '#666',
                        fontSize: 10
                    },
                    splitLine: {
                        show: true,
                        lineStyle: {
                            color: '#222',
                            type: 'dashed'
                        }
                    }
                },
                yAxis: {
                    type: 'value',
                    min: function(value) {
                        return displayRange.min;
                    },
                    max: function(value) {
                        return displayRange.max;
                    },
                    axisLine: {
                        lineStyle: {
                            color: '#333'
                        }
                    },
                    axisTick: {
                        lineStyle: {
                            color: '#333'
                        }
                    },
                    axisLabel: {
                        color: '#666',
                        fontSize: 10,
                        formatter: function(value) {
                            return value.toFixed(1);
                        }
                    },
                    splitLine: {
                        lineStyle: {
                            color: '#222',
                            type: 'dashed'
                        }
                    }
                },
                series: [
                    {
                        name: 'ç¤ºæ³¢å™¨æ•°æ®',
                        type: 'line',
                        smooth: false, // å…³é—­å¹³æ»‘ï¼Œæ›´åƒçœŸå®ç¤ºæ³¢å™¨
                        symbol: 'none', // ä¸æ˜¾ç¤ºæ•°æ®ç‚¹
                        lineStyle: {
                            width: 2,
                            color: '#f7df1e' // ä½¿ç”¨ä½ SVGä¸­çš„é»„è‰²
                        },
                        data: []
                    }
                ]
            };

            myChart.setOption(option);

            // ç›‘å¬çª—å£å¤§å°å˜åŒ–ï¼Œä½¿å›¾è¡¨è‡ªé€‚åº”
            window.addEventListener('resize', () => {
                myChart.resize();
            });

            WEBSOCKET_URL = 'ws://192.168.35.25:8000/ws'

            // WebSocket è¿æ¥
            const ws = new WebSocket(WEBSOCKET_URL);
            let pingInterval;
            
            // æ›´æ–°æ˜¾ç¤ºèŒƒå›´ï¼ˆå¯¹åº”ä½ çš„ updateDisplayRange å‡½æ•°ï¼‰
            function updateDisplayRange(newValue) {
                // è®¡ç®—æœ€è¿‘20ä¸ªæ•°æ®ç‚¹çš„å¹³å‡å€¼
                const recentData = dataPoints.slice(-20);
                const avg = recentData.length > 0 
                    ? recentData.reduce((sum, point) => sum + point.value, 0) / recentData.length 
                    : newValue;
                
                // ä»¥å¹³å‡å€¼ä¸ºä¸­å¿ƒï¼Œè®¾ç½®è¾ƒå¤§çš„æ˜¾ç¤ºèŒƒå›´
                const range = 50; // å¢å¤§æ˜¾ç¤ºèŒƒå›´åˆ°ä¸Šä¸‹å„50ä¸ªå•ä½
                displayRange = {
                    min: avg - range,
                    max: avg + range
                };
                
                // æ›´æ–°å›¾è¡¨Yè½´èŒƒå›´
                myChart.setOption({
                    yAxis: {
                        min: displayRange.min,
                        max: displayRange.max
                    }
                });
            }
            // æ·»åŠ æ•°æ®ç‚¹
            function addDataPoint(value) {
                const now = new Date();
                const timeStr = now.toLocaleTimeString();
                
                dataPoints.push({
                    time: timeStr,
                    value: value,
                    timestamp: now.getTime()
                });
                
                // é™åˆ¶æ•°æ®ç‚¹æ•°é‡
                if (dataPoints.length > maxDataPoints) {
                    dataPoints.shift();
                }
                
                // æ›´æ–°æ˜¾ç¤ºèŒƒå›´
                updateDisplayRange(value);
                // æ›´æ–°å›¾è¡¨
                updateChart();
                
                // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                updateStats(value);
            }
            // æ›´æ–°å›¾è¡¨
            function updateChart() {
                const times = dataPoints.map(point => point.time);
                const values = dataPoints.map(point => point.value);
                
                myChart.setOption({
                    xAxis: {
                        data: times
                    },
                    series: [{
                        data: values
                    }]
                });
            }

            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            function updateStats(newValue) {
                if (dataPoints.length === 0) return;
                
                const values = dataPoints.map(point => point.value);
                currentStats.current = newValue;
                currentStats.max = Math.max(...values);
                currentStats.min = Math.min(...values);
                currentStats.avg = values.reduce((a, b) => a + b, 0) / values.length;
                
                document.getElementById('currentValue').textContent = currentStats.current.toFixed(2);
                document.getElementById('maxValue').textContent = currentStats.max.toFixed(2);
                document.getElementById('minValue').textContent = currentStats.min.toFixed(2);
                document.getElementById('avgValue').textContent = currentStats.avg.toFixed(2);
            }
            // ç»Ÿä¸€çš„ä¼ æ„Ÿå™¨æ•°æ®å¤„ç†å‡½æ•°
            function processSensorData(hexData) {
                // å°†åå…­è¿›åˆ¶å­—ç¬¦ä¸²è½¬æ¢ä¸ºå­—èŠ‚æ•°ç»„
                const packet = [];
                for (let i = 0; i < hexData.length; i += 2) {
                    packet.push(parseInt(hexData.substr(i, 2), 16));
                }
                
                // éªŒè¯ç»“æŸå­—èŠ‚
                if (packet[packet.length - 1] !== 0xFE) {
                    console.error('æ•°æ®æ ¼å¼é”™è¯¯ï¼šç»“æŸå­—èŠ‚ä¸æ˜¯0xFE');
                    return null;
                }
                
                // æ ¹æ®ç¬¬ä¸€ä¸ªå­—èŠ‚åˆ¤æ–­æ•°æ®ç±»å‹å¹¶å¤„ç†
                switch (packet[0]) {
                    case 0x10:
                        const led1 = packet[2];
                        return { type: 'led1', value: led1 };
                    case 0x11:
                        const led2 = packet[2];
                        return { type: 'led2', value: led2 };
                    case 0x12:
                        const led3 = packet[2];
                        return { type: 'led3', value: led3 };
                    case 0x13:
                        const led4 = packet[2];
                        return { type: 'led4', value: led4 };
                    case 0x14:
                        const led5 = packet[2];
                        return { type: 'led5', value: led5 };
                    case 0x15:
                        const led6 = packet[2];
                        return { type: 'led6', value: led6 };
                    case 0x16:
                        const led7 = packet[2];
                        return { type: 'led7', value: led7 };
                    case 0x17:
                        const led8 = packet[2];
                        return { type: 'led6', value: led8 };
                    case 0x18:
                        const led9 = packet[2];
                        return { type: 'led7', value: led9 };
                            
                    case 0x08: // ç¤ºæ³¢å™¨æ•°æ®
                        const oscilloscopeValue = ((packet[1] << 8) | packet[2]) / 100;
                        addDataPoint(oscilloscopeValue);
                        // console.log(`ğŸ“Š ç¤ºæ³¢å™¨æ•°æ®å€¼: ${oscilloscopeValue}`);
                        return { type: 'oscilloscope', value: oscilloscopeValue };
                        
                    case 0x0E: // å…‰ç…§åº¦æ•°æ®
                        const lightValue = (packet[1] << 8) | packet[2];
                        // console.log(`ğŸ’¡ å…‰ç…§åº¦å€¼: ${lightValue} Lux`);
                        return { type: 'light', value: lightValue, unit: 'Lux' };
                        
                        
                    case 0x0B: // æ¸©æ¹¿åº¦æ•°æ®
                        const temperatureValue = packet[1];
                        const humidityValue = packet[2];
                        // console.log(`ğŸŒ¡ï¸ æ¸©åº¦: ${temperatureValue}Â°C, æ¹¿åº¦: ${humidityValue}%`);
                        return { 
                            type: 'temperature_humidity', 
                            temperature: temperatureValue, 
                            humidity: humidityValue,
                            temperatureUnit: 'Â°C',
                            humidityUnit: '%'
                        };

                    case 0x0C: // æµ‹è·æ•°æ®
                        const distanceInMm = (packet[1] << 8) | packet[2];
                        const distanceInCm = distanceInMm / 10;
                        // console.log(`ğŸ“ æµ‹è·å€¼: ${distanceInCm} cm`);
                        return { type: 'distance', value: distanceInCm, unit: 'cm' };
                    
                    case 0x02: // ä¸‡ç”¨è¡¨ç”µé˜»æ¡£ä½
                        const decimalValue = (packet[1] << 8) | packet[2];
                        // console.log(`ğŸ“¥ ç”µé˜»æ•°æ®: ${Array.from(packet).map(n => '0x' + n.toString(16).padStart(2, '0').toUpperCase()).join(' ')} (åè¿›åˆ¶å€¼: ${decimalValue})`);
                        return { type: 'resistance', value: decimalValue, rawPacket: packet };
                        
                    default:
                        console.warn(`âš ï¸ æœªçŸ¥çš„æ•°æ®ç±»å‹: 0x${packet[0].toString(16).padStart(2, '0').toUpperCase()}`);
                        return null;
                }
            }
            // 1. ç›‘å¬ 'open' äº‹ä»¶ï¼šå½“æˆåŠŸå»ºç«‹ WebSocket è¿æ¥æ—¶è§¦å‘
            ws.onopen = () => {
                console.log('[å®¢æˆ·ç«¯] æˆåŠŸè¿æ¥åˆ°æœåŠ¡å™¨');

                // ws.send(JSON.stringify({
                //     type: 'client_message',
                //     payload: { text: 'ä½ å¥½ï¼Œæˆ‘æ˜¯æµè§ˆå™¨å®¢æˆ·ç«¯ï¼', from: 'Web Browser Client' }
                // }));

                // // æ¯éš” 5 ç§’å‘é€ä¸€ä¸ª 'ping' æ¶ˆæ¯
                // pingInterval = setInterval(() => {
                //     if (ws.readyState === WebSocket.OPEN) { // ç¡®ä¿è¿æ¥ä»æ‰“å¼€
                //         ws.send(JSON.stringify({
                //             type: 'ping',
                //             payload: { timestamp: Date.now(), clientName: 'æˆ‘çš„æµè§ˆå™¨å®¢æˆ·ç«¯' }
                //         }));
                //     }
                // }, 5000);
            };

            // 2. ç›‘å¬ 'message' äº‹ä»¶ï¼šå½“æ”¶åˆ°æœåŠ¡å™¨å‘é€çš„æ¶ˆæ¯æ—¶è§¦å‘
            ws.onmessage = (event) => {
                const messageString = event.data; // æµè§ˆå™¨ç¯å¢ƒç›´æ¥é€šè¿‡ event.data è·å–æ•°æ®
                // console.log(`[å®¢æˆ·ç«¯] æ”¶åˆ°åŸå§‹æ¶ˆæ¯: ${messageString}`);

                // console.log("event.data:", event.data, typeof(event.data))
                hexData = event.data;
                data_json = processSensorData(hexData);
                // console.log(data_json);

                // try {
                //     const parsedMessage = JSON.parse(messageString);

                //     // æ ¹æ®æ¶ˆæ¯ç±»å‹å¤„ç†ä¸åŒçš„â€œäº‹ä»¶â€
                //     switch (parsedMessage.type) {
                //         case 'welcome':
                //             console.log(`[å®¢æˆ·ç«¯] æ”¶åˆ°æ¬¢è¿æ¶ˆæ¯:`, parsedMessage.payload);
                //             break;
                //         case 'server_reply':
                //             console.log(`[å®¢æˆ·ç«¯] æ”¶åˆ°æœåŠ¡å™¨å›å¤:`, parsedMessage.payload);
                //             break;
                //         case 'pong':
                //             const latency = Date.now() - parsedMessage.payload.receivedPing;
                //             console.log(`[å®¢æˆ·ç«¯] æ”¶åˆ° Pongï¼Œå»¶è¿Ÿ: ${latency}ms, æœåŠ¡å™¨æ—¶é—´: ${new Date(parsedMessage.payload.timestamp).toLocaleTimeString()}`);
                //             break;
                //         case 'server_broadcast':
                //             console.log(`[å®¢æˆ·ç«¯] æ”¶åˆ°æœåŠ¡å™¨å¹¿æ’­:`, parsedMessage.payload);
                //             // å°†æ–°æ•°æ®æ·»åŠ åˆ° ECharts å›¾è¡¨ä¸­
                //             const newDate = parsedMessage.payload.timestamp;
                //             const newValue = parsedMessage.payload.value;

                //             if (newDate && typeof newValue === 'number') {
                //                 chartDates.push(newDate);
                //                 chartValues.push(newValue);

                //                 // é™åˆ¶æ•°æ®ç‚¹æ•°é‡ï¼Œç§»é™¤æœ€æ—§çš„
                //                 if (chartDates.length > MAX_DATA_POINTS) {
                //                     chartDates.shift();
                //                     chartValues.shift();
                //                 }

                //                 // æ›´æ–° ECharts
                //                 myChart.setOption({
                //                     xAxis: {
                //                         data: chartDates
                //                     },
                //                     series: [{
                //                         data: chartValues
                //                     }]
                //                 });
                //             }
                //             break;
                //         case 'error':
                //             console.error(`[å®¢æˆ·ç«¯] æ”¶åˆ°æœåŠ¡å™¨é”™è¯¯:`, parsedMessage.payload);
                //             break;
                //         default:
                //             console.log(`[å®¢æˆ·ç«¯] æ”¶åˆ°æœªçŸ¥æ¶ˆæ¯ç±»å‹:`, parsedMessage.type, parsedMessage.payload);
                //     }
                // } catch (e) {
                //     console.error(`[å®¢æˆ·ç«¯] æ— æ³•è§£æ JSON æ¶ˆæ¯: ${messageString}, é”™è¯¯: ${e.message}`);
                // }
            };

            // 3. ç›‘å¬ 'close' äº‹ä»¶ï¼šå½“è¿æ¥æ–­å¼€æ—¶è§¦å‘
            ws.onclose = (event) => {
                console.log(`[å®¢æˆ·ç«¯] ä¸æœåŠ¡å™¨æ–­å¼€è¿æ¥ï¼ŒCode: ${event.code}, Reason: ${event.reason || 'æ— '}`);
                clearInterval(pingInterval); // æ¸…é™¤å®šæ—¶å™¨

                // åœ¨ç”Ÿäº§ç¯å¢ƒä¸­ï¼Œè¿™é‡Œé€šå¸¸ä¼šå®ç°è‡ªåŠ¨é‡è¿é€»è¾‘
                setTimeout(() => {
                    console.log('[å®¢æˆ·ç«¯] å°è¯•é‡è¿...');
                    new WebSocket(WEBSOCKET_URL); // ç®€å•çš„é‡è¿å°è¯•
                }, 5000);
            };

            // 4. ç›‘å¬ 'error' äº‹ä»¶ï¼šè¿æ¥å‘ç”Ÿé”™è¯¯æ—¶è§¦å‘
            ws.onerror = (error) => {
                console.error(`[å®¢æˆ·ç«¯] WebSocket é”™è¯¯:`, error);
                clearInterval(pingInterval); // æ¸…é™¤å®šæ—¶å™¨
            };

            // æµè§ˆå™¨ç¯å¢ƒä¸éœ€è¦å¤„ç† process.on('SIGINT')ï¼Œå…³é—­é¡µé¢å³æ–­å¼€è¿æ¥
        });
    </script>
</body>
</html>